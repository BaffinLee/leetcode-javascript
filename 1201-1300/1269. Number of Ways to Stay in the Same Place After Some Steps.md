# 1269. Number of Ways to Stay in the Same Place After Some Steps

- Difficulty: Hard.
- Related Topics: Dynamic Programming.
- Similar Questions: Number of Ways to Reach a Position After Exactly k Steps.

## Problem

You have a pointer at index `0` in an array of size `arrLen`. At each step, you can move 1 position to the left, 1 position to the right in the array, or stay in the same place (The pointer should not be placed outside the array at any time).

Given two integers `steps` and `arrLen`, return the number of ways such that your pointer is still at index `0` after **exactly** `steps` steps. Since the answer may be too large, return it **modulo** `109 + 7`.

 
Example 1:

```
Input: steps = 3, arrLen = 2
Output: 4
Explanation: There are 4 differents ways to stay at index 0 after 3 steps.
Right, Left, Stay
Stay, Right, Left
Right, Stay, Left
Stay, Stay, Stay
```

Example 2:

```
Input: steps = 2, arrLen = 4
Output: 2
Explanation: There are 2 differents ways to stay at index 0 after 2 steps
Right, Left
Stay, Stay
```

Example 3:

```
Input: steps = 4, arrLen = 2
Output: 8
```

 
**Constraints:**


	
- `1 <= steps <= 500`
	
- `1 <= arrLen <= 106`



## Solution

```javascript
/**
 * @param {number} steps
 * @param {number} arrLen
 * @return {number}
 */
var numWays = function(steps, arrLen) {
    if (arrLen === 1) return 1;
    arrLen = Math.min(arrLen, steps);
    var mod = Math.pow(10, 9) + 7;
    var lastArr = Array(arrLen).fill(0);
    lastArr[0] = 1;
    lastArr[1] = 1;
    for (var i = 1; i < steps; i++) {
        var newArr = Array(arrLen);
        for (var j = 0; j < arrLen; j++) {
            newArr[j] = (lastArr[j] + (lastArr[j - 1] || 0) + (lastArr[j + 1] || 0)) % mod;
        }
        lastArr = newArr;
    }
    return lastArr[0];
};
```

**Explain:**

nope.

**Complexity:**

* Time complexity : O(n * min(n * m)).
* Space complexity : O(n).
