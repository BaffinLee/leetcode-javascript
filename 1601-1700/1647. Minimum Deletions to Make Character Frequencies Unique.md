# 1647. Minimum Deletions to Make Character Frequencies Unique

- Difficulty: Medium.
- Related Topics: Hash Table, String, Greedy, Sorting.
- Similar Questions: Minimum Deletions to Make Array Beautiful, Removing Minimum and Maximum From Array, Remove Letter To Equalize Frequency.

## Problem

A string `s` is called **good** if there are no two different characters in `s` that have the same **frequency**.

Given a string `s`, return** the **minimum** number of characters you need to delete to make **`s`** **good**.**

The **frequency** of a character in a string is the number of times it appears in the string. For example, in the string `"aab"`, the **frequency** of `'a'` is `2`, while the **frequency** of `'b'` is `1`.

 
Example 1:

```
Input: s = "aab"
Output: 0
Explanation: s is already good.
```

Example 2:

```
Input: s = "aaabbbcc"
Output: 2
Explanation: You can delete two 'b's resulting in the good string "aaabcc".
Another way it to delete one 'b' and one 'c' resulting in the good string "aaabbc".
```

Example 3:

```
Input: s = "ceabaacb"
Output: 2
Explanation: You can delete both 'c's resulting in the good string "eabaab".
Note that we only care about characters that are still in the string at the end (i.e. frequency of 0 is ignored).
```

 
**Constraints:**


	
- `1 <= s.length <= 105`
	
- `s` contains only lowercase English letters.



## Solution

```javascript
/**
 * @param {string} s
 * @return {number}
 */
var minDeletions = function(s) {
    var frequencyMap = {};
    for (var i = 0; i < s.length; i++) {
        frequencyMap[s[i]] = (frequencyMap[s[i]] || 0) + 1;
    }
    var frequencies = Object.values(frequencyMap).sort((a, b) => b - a);
    var duplicatedFrequencies = [];
    var result = 0;
    for (var j = 0; j < frequencies.length; j++) {
        var frequency = frequencies[j];
        if (frequency === frequencies[j + 1]) {
            duplicatedFrequencies.push(frequency);
            continue;
        }
        while (duplicatedFrequencies.length && frequency > (frequencies[j + 1] || 0) + 1) {
            frequency -= 1;
            result += duplicatedFrequencies.pop() - frequency;
        }
    }
    while (duplicatedFrequencies.length) {
        result += duplicatedFrequencies.pop();
    }
    return result;
};
```

**Explain:**

nope.

**Complexity:**

* Time complexity : O(n).
* Space complexity : O(1).
