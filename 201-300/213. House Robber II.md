# 213. House Robber II

- Difficulty: Medium.
- Related Topics: Array, Dynamic Programming.
- Similar Questions: House Robber, Paint House, Paint Fence, House Robber III, Non-negative Integers without Consecutive Ones, Coin Path.

## Problem

You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are **arranged in a circle.** That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and **it will automatically contact the police if two adjacent houses were broken into on the same night**.

Given an integer array `nums` representing the amount of money of each house, return **the maximum amount of money you can rob tonight **without alerting the police****.

 
Example 1:

```
Input: nums = [2,3,2]
Output: 3
Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.
```

Example 2:

```
Input: nums = [1,2,3,1]
Output: 4
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
Total amount you can rob = 1 + 3 = 4.
```

Example 3:

```
Input: nums = [1,2,3]
Output: 3
```

 
**Constraints:**


	
- `1 <= nums.length <= 100`
	
- `0 <= nums[i] <= 1000`



## Solution

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var rob = function(nums) {
    var arr1 = Array(nums.length); // do not rob the first house
    var arr2 = Array(nums.length); // rob the first house
    for (var i = nums.length - 1; i > 0; i--) {
      arr1[i] = Math.max(nums[i] + (arr1[i + 2] || 0), arr1[i + 1] || 0);
      arr2[i] = i === nums.length - 1 ? 0 : Math.max(nums[i] + (arr2[i + 2] || 0), arr2[i + 1] || 0);
    }
    return Math.max(nums[0] + (arr2[2] || 0), arr1[1] || 0);
};
```

**Explain:**

nope.

**Complexity:**

* Time complexity : O(n).
* Space complexity : O(n).
